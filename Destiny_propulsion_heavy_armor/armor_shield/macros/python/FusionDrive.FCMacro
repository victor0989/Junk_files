# -*- coding: utf-8 -*-
# Macro FreeCAD: Direct Fusion Drive - Ensamblado paramétrico
# Autor: Víctor + Copilot
# Unidades: mm, eje longitudinal = X

import FreeCAD as App
import FreeCADGui as Gui
import Part
import math

doc_name = "Direct_Fusion_Drive"
if App.ActiveDocument is None or App.ActiveDocument.Label != doc_name:
    App.newDocument(doc_name)
doc = App.ActiveDocument

# ============
# Parámetros
# ============
P = {
    # Fuselaje
    "nose_len": 800.0,
    "nose_base_d": 600.0,
    "mid_len": 1400.0,
    "mid_d": 900.0,
    "rear_len": 800.0,
    "rear_d": 1200.0,
    "hull_t": 10.0,

    # Cabina
    "cockpit_w": 900.0,
    "cockpit_h": 400.0,
    "cockpit_l": 600.0,
    "cockpit_x0": 600.0,  # empieza a 600 y termina en 1200

    # Ventanas laterales
    "win_w": 600.0,
    "win_h": 250.0,
    "win_th": 20.0,
    "win_y_off": 0.5*(900.0/2.0 - 250.0/2.0),  # aprox centradas en Y lateral
    "win_z": 0.0,

    # Reactor
    "reactor_d": 800.0,
    "reactor_l": 900.0,
    "reactor_cx": 2600.0,
    "ring_h": 30.0,
    "ring_ro": 420.0,
    "ring_ri": 380.0,
    "ring_n": 6,
    "ring_pitch": 150.0,

    # Coils (solenoides)
    "coil_rect_w": 80.0,
    "coil_rect_h": 80.0,
    "coil_R": 440.0,  # radio medio del coil alrededor del reactor
    "coil_n": 4,      # nº de bobinas distribuidas
    "coil_span": 800.0,  # extensión a lo largo del reactor

    # Blindajes
    "moderator_t": 100.0,
    "moderator_gap": 20.0,
    "moderator_over": 200.0,  # +200mm cada lado total = reactor_l + 200
    "tungsten_post_t": 10.0,  # anillo posterior (axial)

    # Boquilla magnética
    "nozzle_throat_d": 300.0,
    "nozzle_exit_d": 900.0,
    "nozzle_l": 700.0,     # si hay conflicto con 3000 mm, reducir a 500
    "nozzle_cx": 2850.0,
    "nozzle_fillet_r": 40.0,

    # Truss soporte boquilla
    "truss_n": 3,
    "truss_tube_w": 80.0,
    "truss_R_attach": 550.0,  # radio de anclaje en popa

    # Tanques
    "tank_d": 300.0,
    "tank_l": 700.0,
    "tank_cx": 1600.0,
    "tank_cy": 300.0,
    "tank_cz": -150.0,

    # Tren de aterrizaje
    "leg_L_fold": 400.0,
    "leg_L_ext": 600.0,
    "leg_foot_d": 180.0,
    "leg_side_x1": 1050.0,
    "leg_side_x2": 1950.0,
    "leg_side_y": 600.0,
    "leg_front_x": 400.0,
    "leg_front_y": 0.0,
    "leg_front_z": - (900.0/2.0) + 50.0, # bajo fuselaje con margen

    # Alas / empenaje
    "wing_root_w": 600.0,
    "wing_tip_w": 150.0,
    "wing_chord": 450.0,
    "fin_h": 400.0,
    "fin_base": 200.0,

    # Radiadores (opcionales)
    "rad_panel_w": 800.0,
    "rad_panel_h": 600.0,
    "rad_panel_n": 5,
}

# Ejes y utilidades
X_AXIS = App.Vector(1,0,0)
Y_AXIS = App.Vector(0,1,0)
Z_AXIS = App.Vector(0,0,1)

def rot_to_x():
    # Gira un sólido creado por defecto a lo largo de Z para alinearlo con X
    return App.Rotation(Y_AXIS, 90)

def add_obj(shape, label):
    obj = doc.addObject("Part::Feature", label)
    obj.Shape = shape
    return obj

def make_cyl_x(d, L, cx=0.0, cy=0.0, cz=0.0, label="CylX"):
    r = d/2.0
    cyl = Part.makeCylinder(r, L)
    # por defecto extruye en +Z; alineamos a X y movemos para centrar L respecto a su base
    cyl.Placement = App.Placement(App.Vector(cx - L/2.0, cy, cz), rot_to_x())
    return add_obj(cyl, label)

def make_cone_x(d1, d2, L, cx=0.0, cy=0.0, cz=0.0, label="ConeX"):
    r1 = d1/2.0
    r2 = d2/2.0
    cone = Part.makeCone(r1, r2, L)
    cone.Placement = App.Placement(App.Vector(cx - L/2.0, cy, cz), rot_to_x())
    return add_obj(cone, label)

def make_torus_x(R, r, cx=0.0, cy=0.0, cz=0.0, label="TorusX"):
    tor = Part.makeTorus(R, r)
    # Torus por defecto orientado en Z; para eje X, rotamos 90° sobre Y
    tor.Placement = App.Placement(App.Vector(cx, cy, cz), rot_to_x())
    return add_obj(tor, label)

def make_box(w, d, h, cx=0.0, cy=0.0, cz=0.0, label="Box"):
    # box ejes: x=w, y=d, z=h
    b = Part.makeBox(w, d, h)
    b.Placement = App.Placement(App.Vector(cx - w/2.0, cy - d/2.0, cz - h/2.0), App.Rotation())
    return add_obj(b, label)

def make_hollow_from_offset(outer_shape, t, label="Shell"):
    # Crea un “shell” restando el offset interior al sólido exterior
    try:
        inner = outer_shape.makeOffsetShape(-t, 0.01, join=2, fill=True)  # join=2 (intersect), robusto
        shell = outer_shape.cut(inner)
        return add_obj(shell, label)
    except Exception as e:
        # Fallback: devuelve exterior si falla
        return add_obj(outer_shape, label + "_fallback")

def fillet_between(shpA, shpB, r):
    # Intenta un fillet tipo “blend” en la unión de dos sólidos fusionados
    fused = shpA.fuse(shpB)
    # Selección heurística de aristas internas para fillet (puede omitirse si falla)
    try:
        edges = [e for e in fused.Edges if e.Length > 30 and e.Length < 10000]
        new = fused.makeFillet(r, edges)
        return new
    except Exception:
        return fused

def sweep_rect_around_X(R, rw, rh, cx, cy, cz, ax0, ax1, label="CoilSweep"):
    # Crea una bobina rectangular (80x80) barrida alrededor de un círculo cuyo eje es X.
    # Path: círculo en plano YZ, centrado en (cx,cy,cz), radio R
    circ = Part.makeCircle(R, App.Vector(cx,cy,cz), X_AXIS)
    path = Part.Wire([circ])
    # Perfil: rectángulo en plano YZ, centrado en el círculo
    # Creamos un rectángulo como wire
    p0 = App.Vector(0, -rw/2.0, -rh/2.0)
    p1 = App.Vector(0,  rw/2.0, -rh/2.0)
    p2 = App.Vector(0,  rw/2.0,  rh/2.0)
    p3 = App.Vector(0, -rw/2.0,  rh/2.0)
    e1 = Part.makeLine(p0, p1)
    e2 = Part.makeLine(p1, p2)
    e3 = Part.makeLine(p2, p3)
    e4 = Part.makeLine(p3, p0)
    prof = Part.Wire([e1,e2,e3,e4])
    # Colocar perfil en (cx,cy,cz)
    prof.Placement = App.Placement(App.Vector(cx,cy,cz), App.Rotation(X_AXIS,0))
    sweep = Part.Wire(path).makePipeShell([prof], True, True)
    return add_obj(sweep, label)

# =========================
# 1) Fuselaje exterior hueco
# =========================
nose = make_cone_x(P["nose_base_d"], 0.0, P["nose_len"], cx=P["nose_len"]/2.0, label="Nose")
mid  = make_cyl_x(P["mid_d"], P["mid_len"], cx=P["nose_len"] + P["mid_len"]/2.0, label="Mid")
rear = make_cyl_x(P["rear_d"], P["rear_len"], cx=P["nose_len"] + P["mid_len"] + P["rear_len"]/2.0, label="Rear")

# Fusión y “shell” (espesor hacia dentro)
fuse_fuselage_shape = nose.Shape.fuse(mid.Shape).fuse(rear.Shape)
hull = make_hollow_from_offset(fuse_fuselage_shape, P["hull_t"], label="Hull_Shell")

# Ventanas laterales (cortes)
win1 = make_box(P["win_w"], P["win_th"], P["win_h"],
                cx=P["cockpit_x0"] + P["cockpit_l"]/2.0,
                cy= (P["mid_d"]/2.0) - P["win_th"]/2.0,
                cz=P["win_z"],
                label="Win_Right")
win2 = make_box(P["win_w"], P["win_th"], P["win_h"],
                cx=P["cockpit_x0"] + P["cockpit_l"]/2.0,
                cy=-(P["mid_d"]/2.0) + P["win_th"]/2.0,
                cz=P["win_z"],
                label="Win_Left")

hull_cut = add_obj(hull.Shape.cut(win1.Shape).cut(win2.Shape), "Hull_Shell_Cut")

# =========================
# 2) Cabina interior
# =========================
# Caja redondeada: box + fillet en aristas
cockpit_box = Part.makeBox(P["cockpit_l"], P["cockpit_w"], P["cockpit_h"])
cockpit_box.Placement = App.Placement(App.Vector(P["cockpit_x0"], -P["cockpit_w"]/2.0, -P["cockpit_h"]/2.0), App.Rotation())
# Fillet suave
edges = cockpit_box.Edges
try:
    cockpit_f = cockpit_box.makeFillet(20.0, edges)
except Exception:
    cockpit_f = cockpit_box
cockpit = add_obj(cockpit_f, "Cockpit")

# =========================
# 3) Reactor DFD
# =========================
reactor = make_cyl_x(P["reactor_d"], P["reactor_l"], cx=P["reactor_cx"], label="ReactorCore")

# Anillos estructurales
rings = []
x0 = P["reactor_cx"] - P["reactor_l"]/2.0 + P["ring_h"]/2.0
for i in range(P["ring_n"]):
    x = x0 + i * P["ring_pitch"]
    ring = Part.makeTorus((P["ring_ro"]+P["ring_ri"])/2.0, (P["ring_ro"]-P["ring_ri"])/2.0)
    ring.Placement = App.Placement(App.Vector(x,0,0), rot_to_x())
    rings.append(ring)
rings_shape = rings[0]
for r in rings[1:]:
    rings_shape = rings_shape.fuse(r)
rings_obj = add_obj(rings_shape, "Reactor_Rings")

# Coils superconductores (rect. 80x80), n bobinas distribuidas
coils = []
span = P["coil_span"]
cx0 = P["reactor_cx"] - span/2.0
for i in range(P["coil_n"]):
    cx = cx0 + i * (span/(max(1,(P["coil_n"]-1))))
    coil = sweep_rect_around_X(P["coil_R"], P["coil_rect_w"], P["coil_rect_h"], cx, 0.0, 0.0, 0.0, 0.0, label=f"Coil_{i+1}")
    coils.append(coil.Shape)
coils_shape = coils[0]
for c in coils[1:]:
    coils_shape = coils_shape.fuse(c)
coils_obj = add_obj(coils_shape, "Reactor_Coils")

# Blindaje interno posterior (tungsteno) como anillo axial 10 mm en la cara de popa del reactor
tw_len = P["tungsten_post_t"]
tw_ro = P["reactor_d"]/2.0
tw_ri = P["reactor_d"]/2.0 - 10.0  # 10 mm radial aprox
tw_tube = Part.makeCylinder(tw_ro, tw_len)
tw_hole = Part.makeCylinder(tw_ri, tw_len + 0.1)
tw_ring = tw_tube.cut(tw_hole)
tw_ring.Placement = App.Placement(App.Vector(P["reactor_cx"] + P["reactor_l"]/2.0 - tw_len/2.0,0,0), rot_to_x())
tw_obj = add_obj(tw_ring, "Tungsten_Posterior")

# =========================
# 4) Boquilla magnética
# =========================
noz = Part.makeCone(P["nozzle_throat_d"]/2.0, P["nozzle_exit_d"]/2.0, P["nozzle_l"])
noz.Placement = App.Placement(App.Vector(P["nozzle_cx"] - P["nozzle_l"]/2.0,0,0), rot_to_x())
noz_obj = add_obj(noz, "Magnetic_Nozzle")

# Intento de blend/fillet en unión boquilla-cola
try:
    filleted = fillet_between(rear.Shape, noz, P["nozzle_fillet_r"])
    nozzle_mount = add_obj(filleted, "Nozzle_Mount_Fillet")
except Exception:
    nozzle_mount = noz_obj

# Truss de soporte (3 anclajes a 120°)
truss_list = []
for k in range(P["truss_n"]):
    ang = k * (360.0/P["truss_n"])
    # Punto de anclaje en popa (en X cercano a final de rear)
    x_attach = P["nose_len"] + P["mid_len"] + P["rear_len"] - 50.0
    y = P["truss_R_attach"] * math.cos(math.radians(ang))
    z = P["truss_R_attach"] * math.sin(math.radians(ang))
    # Tubo como box rectangular orientado hacia boquilla
    L = 300.0
    beam = Part.makeBox(L, P["truss_tube_w"], P["truss_tube_w"])
    # Orientación: apuntar hacia centro de boquilla
    # Simplificación: alineación en X con ligera apertura radial
    beam.Placement = App.Placement(App.Vector(x_attach - L/2.0, y - P["truss_tube_w"]/2.0, z - P["truss_tube_w"]/2.0), App.Rotation())
    truss_list.append(beam)

truss_shape = truss_list[0]
for t in truss_list[1:]:
    truss_shape = truss_shape.fuse(t)
truss_obj = add_obj(truss_shape, "Nozzle_Truss")

# =========================
# 5) Blindajes principal (moderador) + local (tungsteno)
# =========================
# Moderador: tubo alrededor del reactor con gap 20mm, espesor 100mm, largo reactor + 200
mod_inner_r = P["reactor_d"]/2.0 + P["moderator_gap"]
mod_outer_r = mod_inner_r + P["moderator_t"]
mod_len = P["reactor_l"] + P["moderator_over"]
mod_cx = P["reactor_cx"]

mod_outer = Part.makeCylinder(mod_outer_r, mod_len)
mod_inner = Part.makeCylinder(mod_inner_r, mod_len + 0.2)
mod_tube = mod_outer.cut(mod_inner)
mod_tube.Placement = App.Placement(App.Vector(mod_cx - mod_len/2.0, 0, 0), rot_to_x())
mod_obj = add_obj(mod_tube, "Shield_Moderator")

# Anillo posterior de tungsteno alrededor de tobera (10 mm radial)
tn_ro = P["nozzle_exit_d"]/2.0 + 40.0
tn_ri = tn_ro - 10.0
tn_len = 20.0
tn_tube = Part.makeCylinder(tn_ro, tn_len)
tn_hole = Part.makeCylinder(tn_ri, tn_len + 0.1)
tn_ring = tn_tube.cut(tn_hole)
tn_ring.Placement = App.Placement(App.Vector(P["nozzle_cx"] + P["nozzle_l"]/2.0 - tn_len/2.0,0,0), rot_to_x())
tn_obj = add_obj(tn_ring, "Tungsten_Nozzle_Rim")

# =========================
# 6) Tanques de combustible
# =========================
tank1 = make_cyl_x(P["tank_d"], P["tank_l"],
                   cx=P["tank_cx"], cy=P["tank_cy"], cz=P["tank_cz"], label="Tank_Right")
tank2 = make_cyl_x(P["tank_d"], P["tank_l"],
                   cx=P["tank_cx"], cy=-P["tank_cy"], cz=P["tank_cz"], label="Tank_Left")

# =========================
# 7) Tren de aterrizaje (simplificado)
# =========================
def make_leg(x, y, z, L, d, label):
    shaft = Part.makeCylinder(d/4.0, L)
    foot = Part.makeCylinder(d/2.0, 20.0)
    # eje X
    shaft.Placement = App.Placement(App.Vector(x - L/2.0, y, z), rot_to_x())
    foot.Placement  = App.Placement(App.Vector(x + L/2.0 - 10.0, y, z - d/4.0), App.Rotation())
    leg = shaft.fuse(foot)
    return add_obj(leg, label)

leg_r = make_leg(P["leg_side_x1"],  P["leg_side_y"],  P["leg_front_z"], P["leg_L_fold"], P["leg_foot_d"], "Leg_Right_Front")
leg_l = make_leg(P["leg_side_x1"], -P["leg_side_y"],  P["leg_front_z"], P["leg_L_fold"], P["leg_foot_d"], "Leg_Left_Front")
leg_r2= make_leg(P["leg_side_x2"],  P["leg_side_y"],  P["leg_front_z"], P["leg_L_fold"], P["leg_foot_d"], "Leg_Right_Rear")
leg_l2= make_leg(P["leg_side_x2"], -P["leg_side_y"],  P["leg_front_z"], P["leg_L_fold"], P["leg_foot_d"], "Leg_Left_Rear")
leg_f = make_leg(P["leg_front_x"],  P["leg_front_y"], P["leg_front_z"], P["leg_L_fold"], P["leg_foot_d"], "Leg_Nose")

# =========================
# 8) Aletas / alas cortas
# =========================
def make_trapezoid_wing(root_w, tip_w, chord, thickness=20.0, x0=1400.0, y0=0.0, z0=0.0, side=1, label="Wing"):
    # Perfil trapezoidal extruido: plano XZ, se extiende en +Y para ala derecha, -Y izquierda
    # Polígono en plano XZ (y=0)
    x_le = x0
    x_te = x0 + chord
    z_mid = z0
    # Raíz cerca del fuselaje, punta hacia fuera
    p1 = App.Vector(x_le, 0, z_mid + root_w/2.0)
    p2 = App.Vector(x_te, 0, z_mid + root_w/2.0)
    p3 = App.Vector(x_te, 0, z_mid + tip_w/2.0)
    p4 = App.Vector(x_le, 0, z_mid + tip_w/2.0)
    wire = Part.makePolygon([p1,p2,p3,p4,p1])
    face = Part.Face(wire)
    solid = face.extrude(App.Vector(0, side* (root_w - tip_w), 0))
    # dar espesor real
    slab = Part.makeBox(chord, thickness, (root_w+tip_w)/2.0)
    slab.Placement = App.Placement(App.Vector(x0, side*thickness/2.0, z0 - (root_w+tip_w)/4.0), App.Rotation())
    wing = solid.common(slab)  # recorte para grosor
    return add_obj(wing, label)

wing_r = make_trapezoid_wing(P["wing_root_w"], P["wing_tip_w"], P["wing_chord"],
                             x0=P["nose_len"] + 500.0, y0=0.0, z0=0.0, side=1, label="Wing_Right")
wing_l = make_trapezoid_wing(P["wing_root_w"], P["wing_tip_w"], P["wing_chord"],
                             x0=P["nose_len"] + 500.0, y0=0.0, z0=0.0, side=-1, label="Wing_Left")

# Empeñaje vertical (aleta)
def make_fin(h, base, thickness=20.0, x_base=None, z0=0.0, label="Fin"):
    if x_base is None:
        x_base = P["nose_len"] + P["mid_len"] + P["rear_len"] - 300.0
    # Triángulo en plano XZ
    p1 = App.Vector(x_base, 0, z0)
    p2 = App.Vector(x_base + base, 0, z0)
    p3 = App.Vector(x_base, 0, z0 + h)
    wire = Part.makePolygon([p1,p2,p3,p1])
    face = Part.Face(wire)
    fin = face.extrude(App.Vector(0, thickness, 0))
    fin.Placement = App.Placement(App.Vector(0,-thickness/2.0,0), App.Rotation())
    return add_obj(fin, label)

fin = make_fin(P["fin_h"], P["fin_base"], x_base=P["nose_len"] + P["mid_len"] + 200.0, label="Fin_Vertical")

# =========================
# 9) Radiadores laterales (opcionales, plegables)
# =========================
rads = []
for i in range(P["rad_panel_n"]):
    x = P["nose_len"] + 200.0 + i* (P["rad_panel_w"]/5.0)
    y =  (P["mid_d"]/2.0) + 30.0
    z =  0.0
    panel = Part.makeBox(P["rad_panel_w"], 10.0, P["rad_panel_h"])
    panel.Placement = App.Placement(App.Vector(x - P["rad_panel_w"]/2.0, y - 5.0, z - P["rad_panel_h"]/2.0), App.Rotation())
    rads.append(panel)
    # espejo al otro lado
    panel2 = Part.makeBox(P["rad_panel_w"], 10.0, P["rad_panel_h"])
    panel2.Placement = App.Placement(App.Vector(x - P["rad_panel_w"]/2.0, -y - 5.0, z - P["rad_panel_h"]/2.0), App.Rotation())
    rads.append(panel2)

if rads:
    radS = rads[0]
    for p in rads[1:]:
        radS = radS.fuse(p)
    rads_obj = add_obj(radS, "Radiators")

# =========================
# 10) Montaje lógico (compuestos)
# =========================
grp = doc.addObject("App::Part", "DFD_Ship")
for o in [hull_cut, cockpit, reactor, rings_obj, coils_obj, tw_obj, noz_obj, truss_obj,
          mod_obj, tn_obj, tank1, tank2, leg_r, leg_l, leg_r2, leg_l2, leg_f, wing_r, wing_l, fin]:
    o.adjustRelativeLinks(doc)
    o.removeObjectsFromDocument = False
    grp.addObject(o)

try:
    grp.addObject(rads_obj)
except Exception:
    pass

# =========================
# 11) Propiedades de material (densidades como metadatos)
# =========================
def tag_material(obj, material_name, density):
    try:
        obj.addProperty("App::PropertyString","Material","Physics","Material asignado")
        obj.addProperty("App::PropertyFloat","Density","Physics","Densidad kg/m^3")
    except Exception:
        pass
    obj.Material = material_name
    obj.Density = float(density)

# Asignaciones básicas
tag_material(hull_cut, "Ti-6Al-4V", 4500)
tag_material(reactor, "Estructural", 8000)
tag_material(rings_obj, "Estructural", 8000)
tag_material(coils_obj, "Nb3Sn/NbTi", 8000)
tag_material(mod_obj, "Hydrogen-Composite", 1000)
tag_material(tw_obj, "Tungsten", 19250)
tag_material(tn_obj, "Tungsten", 19250)
tag_material(noz_obj, "Estructural", 8000)
tag_material(truss_obj, "Inconel/Ti", 8500)
tag_material(tank1, "Al7075/Hydride", 2700)
tag_material(tank2, "Al7075/Hydride", 2700)
tag_material(cockpit, "CFRP", 1600)
try:
    tag_material(rads_obj, "Graphene-Composite", 1700)
except Exception:
    pass

# =========================
# 12) Vistas y recomputo
# =========================
doc.recompute()
try:
    Gui.ActiveDocument.ActiveView.viewAxonometric()
    Gui.SendMsgToActiveView("ViewFit")
except Exception:
    pass

print("Macro DFD completada: ensamblaje creado en el documento '{}'.".format(doc.Label))
