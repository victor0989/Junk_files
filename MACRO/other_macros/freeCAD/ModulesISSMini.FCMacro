import FreeCAD as App
import FreeCADGui as Gui
import Part
import math

DOC_NAME = "Modulo_Parker_miniISS"
if App.ActiveDocument is None or App.ActiveDocument.Name != DOC_NAME:
    App.newDocument(DOC_NAME)
doc = App.ActiveDocument

# -----------------------
# Parámetros (mm)
# -----------------------
# -----------------------
# Parámetros principales (mm)
# -----------------------
p = {
    # Núcleo presurizado
    "core_D": 1900.0,       # diámetro exterior total
    "core_L": 2600.0,       # longitud cilindro central
    "liner_t": 2.5,         # espesor liner Al-Li
    "MLI_gap": 25.0,        # separación vacío + MLI

    # Refuerzo acanalado
    "rib_h": 25.0,          # altura nervio
    "rib_t": 3.0,           # espesor nervio
    "rib_pitch": 120.0,     # paso circunferencial

    # Celosía
    "truss_L": 1200.0,      # longitud pórtico
    "truss_OD": 60.0,       # diámetro exterior tubo
    "truss_t": 2.0,         # espesor tubo

    # Paneles solares
    "panel_w": 1600.0,      # ancho (longitud en X)
    "panel_h": 900.0,       # alto (longitud en Y)
    "panel_t": 25.0,        # espesor
    "span": 5000.0,         # distancia ala-ala

    # Motor auxiliar
    "aux_engine_D": 600.0,  # diámetro carcasa
    "aux_engine_L": 850.0,  # longitud carcasa
    "throat": 95.0,         # diámetro cuello tobera
    "exit": 220.0,          # diámetro salida tobera
    "nozzle_L": 350.0,      # longitud tobera

    # Líneas de propelente
    "line_OD": 22.0,        # diámetro exterior
    "line_t": 1.5,          # espesor pared

    # Escudo Whipple
    "whipple_sep": 40.0,    # separación desde domo
    "whipple_t": 2.0        # espesor panel sacrificable
}

# Derivados geométricos
R_total = p["D_exterior_total"] / 2.0
R_env_base_out = R_total - p["h_nervio"]
R_env_base_in  = R_env_base_out - p["t_env_base"]
R_liner_out    = R_env_base_in - p["Gap_vacio_MLI"]
R_liner_in     = R_liner_out - p["t_liner"]

# -----------------------
# Utilidades
# -----------------------
def ensure_part_container(name):
    obj = doc.getObject(name)
    if obj is None:
        obj = doc.addObject("App::Part", name)
    return obj

def add_feature(shape, name, parent=None):
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = shape
    if parent:
        parent.addObject(obj)
    return obj

def polar_positions(n, radius):
    for i in range(n):
        theta = 2 * math.pi * i / n
        yield theta, App.Vector(radius * math.cos(theta), radius * math.sin(theta), 0)

# -----------------------
# Domo torisférico robusto
# -----------------------
def make_torispherical_head(R_ext, t, sag, flip=False):
    """Genera un domo robusto evitando errores OCC y NullShape."""
    import math

    # Si parámetros no son viables, usar semiesfera
    if sag <= t or R_ext <= t:
        return Part.makeSphere(R_ext)

    # --- Exterior ---
    try:
        arco_ext = Part.ArcOfCircle(
            Part.Circle(App.Vector(0,0,0), App.Vector(0,1,0), R_ext),
            0, math.pi/2
        ).toShape()
    except:
        arco_ext = Part.makeLine(App.Vector(R_ext,0,0), App.Vector(0,sag,0))

    eje_ext = Part.makeLine(App.Vector(0,sag,0), App.Vector(0,0,0))
    cierre_ext = Part.makeLine(App.Vector(0,0,0), App.Vector(R_ext,0,0))
    wire_ext = Part.Wire([arco_ext, eje_ext, cierre_ext])
    if not wire_ext.isClosed():
        wire_ext.add(Part.makeLine(wire_ext.Vertexes[-1].Point, wire_ext.Vertexes[0].Point))
    face_ext = Part.Face(wire_ext)
    solid_ext = face_ext.revolve(App.Vector(0,0,0), App.Vector(0,1,0), 360)

    # --- Interior ---
    R_int = R_ext - t
    if R_int <= 0 or sag - t <= 0:
        return solid_ext

    try:
        arco_int = Part.ArcOfCircle(
            Part.Circle(App.Vector(0,0,0), App.Vector(0,1,0), R_int),
            0, math.pi/2
        ).toShape()
    except:
        arco_int = Part.makeLine(App.Vector(R_int,0,0), App.Vector(0,sag-t,0))

    eje_int = Part.makeLine(App.Vector(0,sag-t,0), App.Vector(0,0,0))
    cierre_int = Part.makeLine(App.Vector(0,0,0), App.Vector(R_int,0,0))
    wire_int = Part.Wire([arco_int, eje_int, cierre_int])
    if not wire_int.isClosed():
        wire_int.add(Part.makeLine(wire_int.Vertexes[-1].Point, wire_int.Vertexes[0].Point))
    face_int = Part.Face(wire_int)
    solid_int = face_int.revolve(App.Vector(0,0,0), App.Vector(0,1,0), 360)

    if solid_int.isNull():
        return solid_ext

    head = solid_ext.cut(solid_int)

    if flip:
        head.Placement = App.Placement(App.Vector(0,0,0),
                                       App.Rotation(App.Vector(0,1,0), 180))
    return head

# -----------------------
# 1) Liner con domos
# -----------------------
prt_tanque = ensure_part_container("Tanque_Central")

# Cilindro hueco del liner
outer = Part.makeCylinder(R_liner_out, p["L_cilindro"])
inner = Part.makeCylinder(R_liner_in, p["L_cilindro"])
liner_cyl = outer.cut(inner)

# Domos
head_front = make_torispherical_head(R_liner_out, p["t_liner"], p["Sag_domo"], flip=False)
head_rear  = make_torispherical_head(R_liner_out, p["t_liner"], p["Sag_domo"], flip=True)
head_rear.translate(App.Vector(0,0,p["L_cilindro"]))

liner_total = liner_cyl.fuse([head_front, head_rear])
add_feature(liner_total, "Liner", prt_tanque)

# -----------------------
# 2) Envolvente acanalada
# -----------------------
prt_env = ensure_part_container("Envolvente_Acanalada")

# Cilindro base
env_outer = Part.makeCylinder(R_env_base_out, p["L_cilindro"])
env_inner = Part.makeCylinder(R_env_base_in, p["L_cilindro"])
env_shell = env_outer.cut(env_inner)
add_feature(env_shell, "Envolvente_Base", prt_env)

# Nervios
circ = 2 * math.pi * R_env_base_out
n_ribs = max(6, int(round(circ / p["pitch_rib"])))
rib_len = p["L_cilindro"]
rib_w = p["t_nervio"]
rib_h = p["h_nervio"]

ribs = []
for theta, _ in polar_positions(n_ribs, R_env_base_out + rib_h/2.0):
    rib = Part.makeBox(rib_w, rib_h, rib_len)
    rib.translate(App.Vector(-rib_w/2.0, -rib_h/2.0, 0))
    rib.Placement = App.Placement(App.Vector(0,0,0),
                                  App.Rotation(App.Vector(0,0,1), math.degrees(theta)))
    rib.translate(App.Vector(R_env_base_out + rib_h/2.0, 0, 0))
    ribs.append(rib)

if ribs:
    ribs_fused = ribs[0]
    for r in ribs[1:]:
        ribs_fused = ribs_fused.fuse(r)
    add_feature(ribs_fused, "Nervios", prt_env)

doc.recompute()
Gui.SendMsgToActiveView("ViewFit")

# -----------------------
# 3) Estructura de celosía y paneles
# -----------------------
prt_truss = ensure_part_container("Celosia_Paneles_Motor")

# Posición de origen para pórtico (en X lateral desde generatriz del cilindro)
x_attach = R_env_base_out + 50.0  # pequeño ménsula de 50 mm
span_half = p["ala_span_total"]/2.0
# Marco rectangular con tubos
def make_tube_box(width_y, height_x, length_z, od, t, name):
    # Esqueleto simple con 4 largueros y 4 travesaños (frente y fondo)
    tubes = []
    # nodos
    nodes = [
        App.Vector( R_env_base_out,  span_half, 0),
        App.Vector( R_env_base_out, -span_half, 0),
        App.Vector( R_env_base_out + height_x,  span_half, 0),
        App.Vector( R_env_base_out + height_x, -span_half, 0),
        App.Vector( R_env_base_out,  span_half, length_z),
        App.Vector( R_env_base_out, -span_half, length_z),
        App.Vector( R_env_base_out + height_x,  span_half, length_z),
        App.Vector( R_env_base_out + height_x, -span_half, length_z),
    ]
    # Largueros (x) y travesaños (y)
    pairs = [
        (0,2),(1,3),(4,6),(5,7),  # x-dir
        (0,1),(2,3),(4,5),(6,7),  # y-dir (frente y fondo)
        (0,4),(1,5),(2,6),(3,7),  # z-dir (montantes)
    ]
    for a,b in pairs:
        tubes.append(make_tube_segment(nodes[a], nodes[b], od, t))
    # diagonales básicas en caras
    diag_pairs = [(0,7),(1,6),(2,5),(3,4)]
    for a,b in diag_pairs:
        tubes.append(make_tube_segment(nodes[a], nodes[b], od, t))
    shape = tubes[0]
    for s in tubes[1:]:
        shape = shape.fuse(s)
    return add_feature(shape, name, prt_truss)

truss = make_tube_box(span_half*2, p["L_pórtico"], p["L_pórtico"], p["tubo_OD"], p["tubo_t"], "Portico_Tubular")

# Paneles solares: dos por ala (Y+ y Y-), en línea a lo largo de X (hacia fuera)
def make_panel(x_center, y_center, z_center, L, W, T, name, parent):
    panel = box_centered(L, W, T)
    panel.translate(App.Vector(x_center, y_center, z_center))
    return add_feature(panel, name, parent)

panel_gap = 50.0
x0_panel = R_env_base_out + p["L_pórtico"] - p["panel_L"]/2.0
y_pos = span_half - p["panel_W"]/2.0
y_neg = -span_half + p["panel_W"]/2.0
z_mid = p["L_cilindro"]/2.0

make_panel(x0_panel, y_pos, z_mid + p["panel_T"]/2.0 + 20, p["panel_L"], p["panel_W"], p["panel_T"], "Panel_Yplus_1", prt_truss)
make_panel(x0_panel + p["panel_L"] + panel_gap, y_pos, z_mid + p["panel_T"]/2.0 + 20, p["panel_L"], p["panel_W"], p["panel_T"], "Panel_Yplus_2", prt_truss)
make_panel(x0_panel, y_neg, z_mid + p["panel_T"]/2.0 + 20, p["panel_L"], p["panel_W"], p["panel_T"], "Panel_Yminus_1", prt_truss)
make_panel(x0_panel + p["panel_L"] + panel_gap, y_neg, z_mid + p["panel_T"]/2.0 + 20, p["panel_L"], p["panel_W"], p["panel_T"], "Panel_Yminus_2", prt_truss)

# -----------------------
# 4) Motor lateral + placa de montaje
# -----------------------
prt_motor = ensure_part_container("Motor_Lateral")

motor_R = p["motor_OD"]/2.0
# Montar en lado -Y, cerca del extremo de popa
motor_axis_x = R_env_base_out + p["L_pórtico"]/2.0
motor_axis_y = -(span_half - 300.0)  # un poco hacia dentro para dejar margen a paneles
motor_axis_z = p["L_cilindro"]*0.7

# Carcasa cilíndrica
motor_cyl = Part.makeCylinder(motor_R, p["motor_L"])
motor_cyl.rotate(App.Vector(0,0,0), App.Vector(0,0,1), 90)  # eje en -Y
motor_cyl.translate(App.Vector(motor_axis_x, motor_axis_y - p["motor_L"]/2.0, motor_axis_z))
motor_cyl_obj = add_feature(motor_cyl, "Carcasa_Motor", prt_motor)

# Tobera (conos combinados)
neck_R = p["tobera_cuello"]/2.0
exit_R = p["tobera_salida"]/2.0
# tramo convergente-cilíndrico simple
nozzle = Part.makeCone(exit_R, neck_R, p["tobera_L"])
nozzle.rotate(App.Vector(0,0,0), App.Vector(0,0,1), 90)
# posicionar desde salida pegada a carcasa
nozzle.translate(App.Vector(motor_axis_x, motor_axis_y - p["motor_L"]/2.0 - p["tobera_L"], motor_axis_z))
nozzle_obj = add_feature(nozzle, "Tobera", prt_motor)

# Placa de montaje en truss (para cargas FEM)
plate = Part.makeBox(300, 20, 300)  # 300x20x300 mm
plate.translate(App.Vector(motor_axis_x, motor_axis_y + 50.0, motor_axis_z - 150))
plate_obj = add_feature(plate, "Placa_Motor", prt_motor)

# -----------------------
# 5) Tuberías propelente
# -----------------------
prt_pipes = ensure_part_container("Lineas_Propelente")
# Puerto en el cilindro (lado -Y), hacia popa
port_x = R_liner_out * math.cos(-math.pi/2)
port_y = R_liner_out * math.sin(-math.pi/2)
port_z = p["L_cilindro"]*0.6
P0 = App.Vector(port_x, port_y, port_z)
P1 = App.Vector(R_env_base_out+50, port_y, port_z)
P2 = App.Vector(R_env_base_out+50, motor_axis_y, motor_axis_z)
seg1 = make_tube_segment(P0, P1, p["pipe_OD"], p["pipe_t"])
seg2 = make_tube_segment(P1, P2, p["pipe_OD"], p["pipe_t"])
pipes = seg1.fuse(seg2)
pipes_obj = add_feature(pipes, "Lineas_DN20", prt_pipes)

# Brida de recarga en domo de proa (+X)
prt_interfaces = ensure_part_container("Interfaces")
br_flange_R = p["brida_OD"]/2.0
flange = Part.makeCylinder(br_flange_R, p["brida_t"])
# colocar sobre domo frontal, eje +X: simplificación en x=0 con ligera separación
flange.rotate(App.Vector(0,0,0), App.Vector(0,1,0), 90)
flange.translate(App.Vector(0 + 5.0, 0, p["L_cilindro"]/3.0))
flange_obj = add_feature(flange, "Brida_Recarga", prt_interfaces)

# Taladros M6 en patrón de 6
holes = []
pcd = br_flange_R*0.7
for i in range(p["n_tornillos"]):
    ang = 2*math.pi*i/p["n_tornillos"]
    hx = (0 + 5.0)
    hy = pcd*math.cos(ang)
    hz = p["L_cilindro"]/3.0 + pcd*math.sin(ang)
    hole = Part.makeCylinder(p["tornillo_M"]/2.0, p["brida_t"] + 2.0)
    hole.rotate(App.Vector(0,0,0), App.Vector(0,1,0), 90)
    hole.translate(App.Vector(hx, hy, hz))
    holes.append(hole)
if holes:
    holes_union = holes[0]
    for h in holes[1:]:
        holes_union = holes_union.fuse(h)
    flange_drilled = flange.cut(holes_union)
    flange_obj.Shape = flange_drilled

# -----------------------
# 6) Escudo Whipple de proa
# -----------------------
prt_whipple = ensure_part_container("Whipple")
whipple_R = R_total + 20.0
disc = Part.makeCylinder(whipple_R, p["whipple_t"])
disc.rotate(App.Vector(0,0,0), App.Vector(0,1,0), 90)
disc.translate(App.Vector(-p["whipple_gap"], 0, p["L_cilindro"]/2.0))
add_feature(disc, "Whipple_Proa", prt_whipple)

# -----------------------
# 7) FEM: contenedor, materiales y cargas básicas
# -----------------------
try:
    import Fem
    import ObjectsFem
    prt_fem = ensure_part_container("FEM")

    analysis = doc.addObject('Fem::FemAnalysis', 'Analysis')
    prt_fem.addObject(analysis)

    # Materiales aproximados
    mat_liner = ObjectsFem.makeMaterialSolid(doc, 'Mat_AlLi2195')
    mat_liner.Material = {
        'Name':'Al-Li 2195',
        'YoungsModulus':'76000000000 Pa',
        'PoissonRatio':'0.33',
        'Density':'2650 kg/m^3'
    }
    analysis.addObject(mat_liner)
    mat_titanio = ObjectsFem.makeMaterialSolid(doc, 'Mat_Ti64')
    mat_titanio.Material = {
        'Name':'Ti-6Al-4V',
        'YoungsModulus':'114000000000 Pa',
        'PoissonRatio':'0.34',
        'Density':'4430 kg/m^3'
    }
    analysis.addObject(mat_titanio)

    # Asignar materiales por objeto (nota: para cálculo real, usar sólidos separados/meshes por material)
    mat_liner.References = [(liner_obj, '')]
    mat_titanio.References = [(truss, '')]

    # Presión interna 1.5 bar(g) en cara cilíndrica interior del liner
    # Filtrar cara cilíndrica de radio ~ R_liner_in
    cyl_faces = []
    for f in liner_obj.Shape.Faces:
        try:
            surf = f.Surface
            if hasattr(surf, 'Radius') and abs(surf.Radius - R_liner_in) < 1.0:
                cyl_faces.append((liner_obj, f))
        except:
            pass
    if cyl_faces:
        pres = ObjectsFem.makeConstraintPressure(doc, 'Presion_Interna')
        pres.Pressure = 150000  # Pa
        pres.References = [(liner_obj, [f for f in range(1, len(liner_obj.Shape.Faces)+1) if abs(getattr(liner_obj.Shape.Faces[f-1].Surface,'Radius',0)-R_liner_in)<1.0])]
        analysis.addObject(pres)

    # Inercia 6g axial (+X)
    g = ObjectsFem.makeConstraintSelfWeight(doc, 'Inercia_6g')
    g.Gravity_x = 9.81*6
    g.Gravity_y = 0
    g.Gravity_z = 0
    analysis.addObject(g)

    # Fuerza 5 kN en placa de motor (para torsión excéntrica)
    force = ObjectsFem.makeConstraintForce(doc, 'Empuje_Descentrado')
    force.Force = 5000.0
    # aplicar en cara grande superior de la placa (puedes ajustar el índice si es necesario)
    face_ids = [i+1 for i,f in enumerate(plate_obj.Shape.Faces) if abs(f.BoundBox.XLength-300)<1 and abs(f.BoundBox.ZLength-300)<1]
    if face_ids:
        force.References = [(plate_obj, face_ids)]
    analysis.addObject(force)

    # Solver modal (frecuencias) y estático (placeholders)
    solver = ObjectsFem.makeSolverCalculixCcxTools(doc, 'SolverCcx')
    solver.AnalysisType = 'frequency'
    analysis.addObject(solver)

    # Malla placeholder (requiere Gmsh/Netgen instalados para ejecutar el solve)
    mesh = doc.addObject('Fem::FemMeshObject', 'Mesh')
    analysis.addObject(mesh)

except Exception as e:
    App.Console.PrintMessage("FEM setup parcial: revisa Workbench FEM instalado.\n")

doc.recompute()
Gui.SendMsgToActiveView("ViewFit")
