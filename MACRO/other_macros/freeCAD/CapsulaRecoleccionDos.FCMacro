# -*- coding: utf-8 -*-
# Parker Solar Probe-like – Macro FreeCAD: bus + TPS + palas + radiadores + instrumentos + antena trasera + racks
# Genera sólidos y exporta a STEP AP214

import math
import FreeCAD as App
import Part

# ===================== Parámetros globales (mm) =====================
# Bus (cuerpo)
p_bus_w = 90.0   # eje X (frente-atrás)
p_bus_d = 90.0   # eje Y (lado-lado)
p_bus_h = 120.0  # eje Z (arriba-abajo)
bus_skin_t = 2.0

# Escudo térmico (TPS)
shield_d = 220.0
shield_thk = 12.0
shield_cone = 22.0        # controla el estrechamiento radial
shield_gap = 28.0         # separación entre bus y escudo (dirección +X)
shield_back_standoff = 10.0

# Palas solares
paddle_len = 85.0
paddle_root_w = 44.0
paddle_tip_w = 26.0
paddle_t = 2.0
paddle_y_offset = p_bus_d/2.0 - 8.0
paddle_tilt_deg = 22.0     # inclinación en torno al eje Z desde +X

# Radiadores
radiator_w = 80.0   # ancho (Y)
radiator_h = 120.0  # alto (Z)
radiator_t = 2.2    # espesor base (X)
radiator_back_offset = 46.0
radiator_fin_pitch = 12.0
radiator_fin_w = 1.2
radiator_fin_len = 10.0   # longitud aleta en -X

# Instrumentos delanteros
faraday_len = 48.0
faraday_r   = 12.0
whip_len = 160.0
whip_r   = 0.9

# Antena trasera
back_dish_d      = 120.0     # diámetro del plato
back_dish_depth  = 25.0      # profundidad de la parábola (eje)
steps_profile    = 72        # discretización del perfil (>= 36 recomendable)
t_bumper_ring    = 1.2       # grosor radial del aro toroidal del borde
boom_len_back = 80.0
boom_r        = 1.8
boom_tip_r    = 4.0

# Capas del plato [ (t, (r,g,b), alpha) ] ; colores normalizados 0..1
layers_rear_dish = [
    (0.8,  (0.41,0.41,0.41), 0.95),  # C/C bumper - dimgray
    (0.3,  (0.63,0.32,0.18), 0.55),  # Epoxy unión - sienna
    (3.0,  (0.85,0.65,0.13), 0.55),  # Kevlar+epoxy - goldenrod
]

# Racks laterales (placeholders, ajusta a tu diseño)
rack_gap_from_bus = 6.0
rack_x_pos = -10.0  # centrado en X dentro del bus; ajusta
rack_prop_size   = (70.0, 26.0, 40.0)   # (X,Y,Z) - Propulsión iónica
rack_water_size  = (60.0, 22.0, 40.0)   # (X,Y,Z) - Recolección de agua
rack_aqua_size   = (70.0, 30.0, 50.0)   # (X,Y,Z) - Aquatech TradeRack

# Exportación
export_path = App.getUserAppDataDir() + "ParkerProbe.step"  # cambia si quieres

# ===================== Utilidades geométricas =====================
def parabola_r(z, d, depth):
    # r(z) = sqrt(4 f z), con f = d^2 / (16*depth)
    if depth <= 0: return 0.0
    f = (d*d) / (16.0*depth)
    val = 4.0*f*z
    return math.sqrt(val) if val > 0 else 0.0

def make_revolved_solid_from_diameter(d, depth, steps=72, z0_eps_factor=1.0):
    """
    Sólido de revolución (macizo) del volumen bajo la curva r(z), z ∈ [z0, depth].
    Eje de revolución: Z. Perfil en plano XZ (y=0), x=r(z).
    """
    if d <= 0 or depth <= 0:
        return None
    steps = max(24, int(steps))
    z0 = depth / (steps * z0_eps_factor)  # evita el eje degenerado

    # Contorno
    p_axis_bot = App.Vector(0, 0, z0)
    p_axis_top = App.Vector(0, 0, depth)
    e_axis = Part.makeLine(p_axis_bot, p_axis_top)

    r_max = parabola_r(depth, d, depth)
    p_top_out = App.Vector(r_max, 0, depth)
    e_top = Part.makeLine(p_axis_top, p_top_out)

    outer_pts = []
    for i in range(steps+1):
        z = depth - (depth - z0) * (i/steps)
        r = parabola_r(z, d, depth)
        outer_pts.append(App.Vector(r, 0, z))
    e_curve = Part.makePolygon(outer_pts)

    p_bot_out = outer_pts[-1]
    e_bot = Part.makeLine(p_bot_out, p_axis_bot)

    wire = Part.Wire([e_axis, e_top, e_curve, e_bot])
    face = Part.Face(wire)
    solid = face.revolve(App.Vector(0,0,0), App.Vector(0,0,1), 360)
    return solid

def make_dish_layer_solid(d, depth, t, steps=72):
    """
    Capa del plato como sólido: outer - inner (d_inner ≈ d - 2*t)
    """
    d_eff = max(d, 0.1)
    outer = make_revolved_solid_from_diameter(d_eff, depth, steps)
    d_inner = d_eff - 2.0*t
    if d_inner <= 0.1:
        return outer
    inner = make_revolved_solid_from_diameter(d_inner, depth, steps)
    return outer.cut(inner)

def make_ring(r_outer, r_inner, h):
    outer = Part.makeCylinder(r_outer, h)
    inner = Part.makeCylinder(r_inner, h)
    return outer.cut(inner)

def place_shape(shape, pos=App.Vector(0,0,0), rot_axis=App.Vector(0,1,0), rot_deg=0):
    sh = shape.copy()
    pl = App.Placement()
    pl.Rotation = App.Rotation(rot_axis, rot_deg)
    pl.Base = pos
    sh.Placement = pl
    return sh

def add_part(doc, shape, name, color=(0.8,0.8,0.8), transparency=0):
    if shape is None: return None
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = shape
    try:
        obj.ViewObject.ShapeColor = color
        obj.ViewObject.Transparency = int(max(0, min(100, round(transparency*100))))
    except Exception:
        pass
    return obj

def make_trapezoid_plate(len_x, w_root, w_tip, t_y):
    """
    Placa trapezoidal en plano XZ, extruida en Y (centrada en Y).
    """
    x0, x1 = 0.0, len_x
    z0 = -w_root/2.0
    z1 =  w_root/2.0
    z2 =  w_tip/2.0
    z3 = -w_tip/2.0
    pts = [
        App.Vector(x0,0,z0), App.Vector(x0,0,z1),
        App.Vector(x1,0,z2), App.Vector(x1,0,z3),
        App.Vector(x0,0,z0)
    ]
    wire = Part.Wire(Part.makePolygon(pts))
    face = Part.Face(wire)
    solid = face.extrude(App.Vector(0, t_y, 0))
    # centrar en Y
    return place_shape(solid, pos=App.Vector(0,-t_y/2.0,0), rot_axis=App.Vector(1,0,0), rot_deg=0)

# ===================== Subconjuntos =====================
def build_bus(doc):
    # Caja del bus centrada en el origen
    box = Part.makeBox(p_bus_w, p_bus_d, p_bus_h)
    box.translate(App.Vector(-p_bus_w/2.0, -p_bus_d/2.0, -p_bus_h/2.0))
    return [add_part(doc, box, "BusBody", color=(0.35,0.35,0.40), transparency=0)]

def build_heat_shield(doc):
    objs = []
    # Frustum por capas; eje Z → rotar a eje X
    r0 = shield_d/2.0
    r1 = r0 - shield_cone*0.25
    r2 = r0 - shield_cone*0.85
    r3 = r0 - shield_cone

    h_front = 1.6
    h_core  = max(1.0, shield_thk - 3.2)
    h_back  = max(1.0, shield_thk - (h_front + h_core))  # ajusta suma

    x0 = p_bus_w/2.0 + shield_gap  # plano trasero del escudo

    front = Part.makeCone(r0, r1, h_front)
    core  = Part.makeCone(r1, r2, h_core)
    back  = Part.makeCone(r2, r3, h_back)

    frontX = place_shape(front, pos=App.Vector(x0,0,0), rot_axis=App.Vector(0,1,0), rot_deg=90)
    coreX  = place_shape(core,  pos=App.Vector(x0+h_front,0,0), rot_axis=App.Vector(0,1,0), rot_deg=90)
    backX  = place_shape(back,  pos=App.Vector(x0+h_front+h_core,0,0), rot_axis=App.Vector(0,1,0), rot_deg=90)

    objs.append(add_part(doc, frontX, "TPS_Front", color=(0.98,0.98,0.98), transparency=0))
    objs.append(add_part(doc, coreX,  "TPS_Core",  color=(0.40,0.40,0.40), transparency=0))
    objs.append(add_part(doc, backX,  "TPS_Back",  color=(0.05,0.05,0.05), transparency=0))

    # Aro soporte detrás del escudo
    ring_Z = make_ring(r_outer=(shield_d/2.0 - 12.0), r_inner=(shield_d/2.0 - 18.0), h=3.0)
    ring_X = place_shape(ring_Z, pos=App.Vector(x0 - shield_back_standoff, 0, 0), rot_axis=App.Vector(0,1,0), rot_deg=90)
    objs.append(add_part(doc, ring_X, "TPS_SupportRing", color=(0.75,0.75,0.75), transparency=0))

    # 6 viguetas a 60°
    for a in range(0,360,60):
        cyl = Part.makeCylinder(2.6, shield_back_standoff + 4.0)
        cylX = place_shape(cyl, rot_axis=App.Vector(0,1,0), rot_deg=90)
        y = (shield_d/2.0 - 18.0) * math.cos(math.radians(a))
        z = (shield_d/2.0 - 18.0) * math.sin(math.radians(a))
        cylX.translate(App.Vector(x0 - shield_back_standoff, y, z))
        objs.append(add_part(doc, cylX, f"TPS_Strut_{a}", color=(0.75,0.75,0.75), transparency=0))

    # Sensores en el borde del escudo
    for a in range(0,360,45):
        ang = math.radians(a)
        y = (shield_d/2.0 - 6.0) * math.cos(ang)
        z = (shield_d/2.0 - 6.0) * math.sin(ang)
        s = Part.makeSphere(2.2)
        s.translate(App.Vector(x0 + shield_thk + 2.0, y, z))
        objs.append(add_part(doc, s, f"TPS_RimSensor_{a}", color=(1.0,0.9,0.2), transparency=0))
    return [o for o in objs if o is not None]

def build_paddle(doc, side=+1):
    """
    side = +1 para Y positivo, -1 para Y negativo
    """
    plate = make_trapezoid_plate(paddle_len, paddle_root_w, paddle_tip_w, paddle_t)
    hinge = Part.makeCylinder(2.2, 4.0, App.Vector(0,0,0), App.Vector(1,0,0))
    hinge = place_shape(hinge, rot_axis=App.Vector(0,1,0), rot_deg=90)

    tilt = paddle_tilt_deg * (1 if side>0 else -1)
    plate_rot = place_shape(plate, rot_axis=App.Vector(0,0,1), rot_deg=tilt)
    hinge_rot = place_shape(hinge, rot_axis=App.Vector(0,0,1), rot_deg=tilt)

    # Ubicación cerca del borde frontal del bus
    x = p_bus_w/2.0 - 6.0
    y = side*(paddle_y_offset + paddle_t/2.0 + 2.0)
    z = 0.0
    plate_rot.translate(App.Vector(x, y, z))
    hinge_rot.translate(App.Vector(x, y, z))

    o1 = add_part(doc, plate_rot, f"Paddle_{'P' if side>0 else 'N'}", color=(0.03,0.09,0.30), transparency=0)
    o2 = add_part(doc, hinge_rot, f"PaddleHinge_{'P' if side>0 else 'N'}", color=(0.75,0.75,0.75), transparency=0)
    return [o for o in [o1,o2] if o is not None]

def build_radiator(doc, side=+1):
    """
    Radiador plano con aletas, detrás del bus.
    Dos radiadores (±Y), a una distancia fija en -X.
    """
    objs = []
    # Placa base (paralela a YZ): espesor en X
    plate = Part.makeBox(radiator_t, radiator_w, radiator_h)
    plate.translate(App.Vector(-radiator_t/2.0, -radiator_w/2.0, -radiator_h/2.0))

    x = -p_bus_w/2.0 - radiator_back_offset
    y = side*(p_bus_d/2.0 + rack_gap_from_bus + radiator_w/2.0)  # despega del bus hacia ±Y
    z = 0.0
    plate = place_shape(plate, pos=App.Vector(x, y, z))
    objs.append(add_part(doc, plate, f"RadiatorPlate_{'P' if side>0 else 'N'}", color=(0.75,0.75,0.78), transparency=0))

    # Aletas: tiras a lo largo de Y, repartidas en Z
    n_fins = max(0, int(radiator_h // radiator_fin_pitch))
    z0 = -radiator_h/2.0 + radiator_fin_pitch/2.0
    for i in range(n_fins):
        z_i = z0 + i*radiator_fin_pitch
        fin = Part.makeBox(radiator_fin_len, radiator_w, radiator_fin_w)
        # Colocar la base de la aleta pegada al borde trasero de la placa (más -X)
        fin.translate(App.Vector(-radiator_fin_len - radiator_t/2.0, -radiator_w/2.0, -radiator_fin_w/2.0))
        fin = place_shape(fin, pos=App.Vector(x, y, z_i))
        objs.append(add_part(doc, fin, f"RadiatorFin_{'P' if side>0 else 'N'}_{i}", color=(0.65,0.65,0.68), transparency=0))
    return objs

def build_instruments_front(doc):
    """
    Faraday cup + antena látigo al frente (+X)
    """
    objs = []
    x_front = p_bus_w/2.0 + shield_gap/2.0

    # Faraday cup (cilindro)
    faraday = Part.makeCylinder(faraday_r, faraday_len, App.Vector(x_front, 0, 0), App.Vector(1,0,0))
    objs.append(add_part(doc, faraday, "FaradayCup", color=(0.85,0.85,0.85), transparency=0))

    # Antena látigo (whip)
    whip = Part.makeCylinder(whip_r, whip_len, App.Vector(x_front + faraday_len + 6.0, 0, 0), App.Vector(1,0,0))
    objs.append(add_part(doc, whip, "WhipAntenna", color=(0.90,0.90,0.95), transparency=0))
    return objs

def build_back_antenna(doc):
    """
    Plato parabólico multicapa orientado a -X + boom y aro de protección.
    """
    objs = []
    # Construir capas del plato
    dish_layers = []
    for idx, (t, col, alpha) in enumerate(layers_rear_dish):
        ly = make_dish_layer_solid(back_dish_d, back_dish_depth, t, steps_profile)
        # Rotar el sólido para que su eje sea -X (desde Z → -X rotando -90° sobre Y)
        ly = place_shape(ly, rot_axis=App.Vector(0,1,0), rot_deg=-90)
        # Posicionar detrás del bus
        x_dish = -p_bus_w/2.0 - boom_len_back - back_dish_depth
        ly.translate(App.Vector(x_dish, 0, 0))
        dish_layers.append(add_part(doc, ly, f"BackDishLayer_{idx}", color=col, transparency=1.0 - alpha))
    objs += dish_layers

    # Bumper ring (toro) en el borde del plato
    tor_R = back_dish_d/2.0
    tor_r = t_bumper_ring
    torus = Part.makeTorus(tor_R, tor_r)
    # Eje del toro a lo largo de -X: rotar -90° Y y llevar al borde (x = x_dish - pequeño offset)
    torus = place_shape(torus, rot_axis=App.Vector(0,1,0), rot_deg=-90)
    torus.translate(App.Vector(-p_bus_w/2.0 - boom_len_back - back_dish_depth, 0, 0))
    objs.append(add_part(doc, torus, "BackDishBumper", color=(0.35,0.35,0.35), transparency=0))

    # Boom trasero (hacia -X) + punta
    boom = Part.makeCylinder(boom_r, boom_len_back, App.Vector(-p_bus_w/2.0, 0, 0), App.Vector(-1,0,0))
    objs.append(add_part(doc, boom, "BackBoom", color=(0.75,0.75,0.75), transparency=0))
    tip = Part.makeSphere(boom_tip_r)
    tip.translate(App.Vector(-p_bus_w/2.0 - boom_len_back, 0, 0))
    objs.append(add_part(doc, tip, "BackBoomTip", color=(0.85,0.85,0.90), transparency=0))
    return [o for o in objs if o is not None]

def build_racks(doc):
    """
    Tres racks en el lateral +Y del bus, sujetos mediante una placa simple.
    - Rack de propulsión iónica
    - Rack de recolección de agua
    - Aquatech TradeRack (filtrado/almacenamiento)
    """
    objs = []
    # Placa soporte lateral
    plate_h = p_bus_h
    plate_w = 4.0
    plate = Part.makeBox(plate_w, plate_h, 4.0)  # X=4, Y=altura, Z=4 (solo un herraje simbólico)
    # colocar al lateral +Y del bus, centrado en Z, a ras del bus
    plate.translate(App.Vector(-plate_w/2.0, -plate_h/2.0, -2.0))
    plate = place_shape(plate, pos=App.Vector(0.0, p_bus_d/2.0 + 1.0, 0.0), rot_axis=App.Vector(1,0,0), rot_deg=90)
    objs.append(add_part(doc, plate, "SideMountPlate", color=(0.6,0.6,0.6), transparency=0))

    def make_rack(name, size_xyz, y_order, color):
        sx, sy, sz = size_xyz
        # Caja del rack
        rack = Part.makeBox(sx, sy, sz)
        rack.translate(App.Vector(-sx/2.0, -sy/2.0, -sz/2.0))
        # Posición: colgar en +Y, escalonado en Z
        x = rack_x_pos
        y = p_bus_d/2.0 + rack_gap_from_bus + sy/2.0
        z = -p_bus_h/4.0 + y_order*(sz + 6.0)  # 3 niveles aprox.
        rack = place_shape(rack, pos=App.Vector(x, y, z))
        return add_part(doc, rack, name, color=color, transparency=0)

    objs.append(make_rack("Rack_PropulsionIonica", rack_prop_size, 0, (0.80,0.80,0.85)))
    objs.append(make_rack("Rack_RecoleccionAgua",  rack_water_size, 1, (0.70,0.85,0.95)))
    objs.append(make_rack("Rack_AquatechTrade",    rack_aqua_size,  2, (0.90,0.80,0.50)))
    return [o for o in objs if o is not None]

# ===================== Ensamblado y exportación =====================
def main():
    doc = App.newDocument("ParkerLike")
    objs = []
    objs += build_bus(doc)
    objs += build_heat_shield(doc)
    objs += build_paddle(doc, +1)
    objs += build_paddle(doc, -1)
    objs += build_radiator(doc, +1)
    objs += build_radiator(doc, -1)
    objs += build_instruments_front(doc)
    objs += build_back_antenna(doc)
    objs += build_racks(doc)

    doc.recompute()
    try:
        Part.export([o for o in objs if o is not None], export_path)
        App.Console.PrintMessage("STEP exportado a: %s\n" % export_path)
    except Exception as e:
        App.Console.PrintError("No se pudo exportar STEP: %s\n" % e)
    return doc

# Ejecutar
main()
