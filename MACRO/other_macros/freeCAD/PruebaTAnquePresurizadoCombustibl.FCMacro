# FreeCAD macro: Tanque criogénico presurizado - ensamble detallado
# Autor: Asistente (para Víctor)
# Uso: Pegar en FreeCAD -> Macro -> New o ejecutar en la consola de Python

import FreeCAD as App
import FreeCADGui as Gui
import Part, Draft, math

# ---------------------- PARAMETROS (ajusta aquí en mm) ----------------------
# Unidades internas: mm
scale = 1.0
D_outer = 1200.0           # diametro jacket exterior
D_inner = 1050.0           # diametro liner interior
L_cyl = 2500.0             # longitud del cilindro (sin domos)
t_liner = 8.0              # espesor liner
t_jacket = 12.0            # espesor jacket
n_supports = 6             # soportes termicos
flange_outer = 80.0        # ancho cinta del brida
flange_thick = 20.0        # espesor de la brida
bolt_d = 10.0              # diametro de los pernos
bolt_count = 12            # numero de pernos en brida
port_r = 30.0              # radio de puertos (externo)
port_len = 120.0           # longitud de puertos
pmd_vanes = 6              # numero de vanes PMD internos

deg_to_rad = math.pi/180.0

# ---------------------- Crear nuevo documento ----------------------
doc = App.newDocument("TanqueCriogenico_Assemblado")

# ---------------------- Helper functions ----------------------
def add_part(shape, name):
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = shape
    return obj

def make_torispherical_dome(r_outer, crown_h, name):
    # aproximacion simple con esfera cortada: usa sphere radius = r_outer
    sphere = Part.makeSphere(r_outer)
    # cortar por plano para crear dome height = crown_h
    cut_z = r_outer - crown_h
    box = Part.makeBox(r_outer*4, r_outer*4, r_outer*2)
    box.translate(App.Vector(-r_outer*2, -r_outer*2, -r_outer))
    dome = sphere.cut(box)
    return dome

# ---------------------- Geometrias principales ----------------------
# Radios
r_in = D_inner/2.0
r_out = D_outer/2.0

# DOMOS (usar proporcion h ~ 0.4*r)
dome_h_in = r_in * 0.38
dome_in_A = make_torispherical_dome(r_in, dome_h_in, "dome_in_A")
dome_in_B = make_torispherical_dome(r_in, dome_h_in, "dome_in_B")

dome_h_out = r_out * 0.38
dome_out_A = make_torispherical_dome(r_out, dome_h_out, "dome_out_A")
dome_out_B = make_torispherical_dome(r_out, dome_h_out, "dome_out_B")

# Crear cilindro liner (interior)
cyl_in = Part.makeCylinder(r_in, L_cyl)
# posicion domos para liner
dome_in_A.translate(App.Vector(0,0,-dome_h_in))
dome_in_B.translate(App.Vector(0,0,L_cyl))
liner_shape = cyl_in.fuse(dome_in_A).fuse(dome_in_B)
liner = add_part(liner_shape, "Liner")

# Crear jacket exterior (hollow): cilindro + domos, luego restar hueco
cyl_out = Part.makeCylinder(r_out, L_cyl + 2*dome_h_out)
# posicion domos para jacket
dome_out_A.translate(App.Vector(0,0,-dome_h_out))
dome_out_B.translate(App.Vector(0,0,L_cyl + dome_h_out))
jacket_union = cyl_out.fuse(dome_out_A).fuse(dome_out_B)
# crear corte interior para dejar hueco entre liner y jacket
hueco_r = r_in + (r_out - r_in)*0.6  # dejar algo de gap, con tolerancia
hueco = Part.makeCylinder(hueco_r, L_cyl + 2*dome_h_out)
hueco.translate(App.Vector(0,0,-dome_h_out))
jacket_hollow = jacket_union.cut(hueco)
jacket = add_part(jacket_hollow, "Jacket")

# ---------------------- Brida/Flange con patron de pernos ----------------------
# Brida en uno de los extremos (por ejemplo, extremo A)
flange_r_outer = r_out + flange_outer
flange_r_inner = r_out - flange_outer*0.4
flange = Part.makeCylinder(flange_r_outer, flange_thick)
cut_flange_hole = Part.makeCylinder(flange_r_inner, flange_thick + 2)
flange_shell = flange.cut(cut_flange_hole)
# posicionar flange en extremo A (z = -dome_h_out - flange_thick)
flange_shell.translate(App.Vector(0,0,-dome_h_out - flange_thick))
flange_obj = add_part(flange_shell, "Flange")

# Patron de pernos
bolt_circle_r = (flange_r_inner + flange_r_outer)/2.0
for i in range(bolt_count):
    ang = 2*math.pi/bolt_count * i
    x = bolt_circle_r * math.cos(ang)
    y = bolt_circle_r * math.sin(ang)
    hole = Part.makeCylinder(bolt_d/2.0, flange_thick + 2)
    hole.translate(App.Vector(x, y, -dome_h_out - flange_thick))
    flange_shell = flange_shell.cut(hole)
# actualizar flange con agujeros
flange_obj.Shape = flange_shell

# ---------------------- Crear puertos con bridas y roscas simplificadas ----------------------
# Feed port (lado lateral, a mitad de longitud)
feed_port = Part.makeCylinder(port_r, port_len)
# posicion lateral en angulo 30deg
theta = 30*deg_to_rad
x_feed = (r_in + (r_out-r_in)/2.0) * math.cos(theta)
y_feed = (r_in + (r_out-r_in)/2.0) * math.sin(theta)
feed_port.translate(App.Vector(x_feed, y_feed, L_cyl*0.5 - port_len*0.5))
feed_obj = add_part(feed_port, "FeedPort")

# Purge port (opuesto)
purge_port = Part.makeCylinder(port_r*0.8, port_len*0.8)
purge_port.translate(App.Vector(-x_feed, -y_feed, L_cyl*0.5 - port_len*0.4))
purge_obj = add_part(purge_port, "PurgePort")

# PRV (valvula de seguridad) - tubito pequeño en extremo B
prv = Part.makeCylinder(15.0, 60.0)
prv.translate(App.Vector(r_out*0.7, 0, L_cyl + dome_h_out*0.6))
prv_obj = add_part(prv, "PRV")

# ---------------------- Soportes termicos (n_supports) ----------------------
strut_r = 10.0
strut_len = L_cyl*0.9
for i in range(n_supports):
    ang = 2*math.pi/n_supports * i
    x = (r_in + r_out)/2.0 * math.cos(ang)
    y = (r_in + r_out)/2.0 * math.sin(ang)
    strut = Part.makeCylinder(strut_r, strut_len)
    strut.translate(App.Vector(x, y, L_cyl*0.05))
    add_part(strut, "Strut_%d"%i)

# ---------------------- PMD interno: vanes helicoidales (approximado) ----------------------
# Crear pmd como serie de placas helicoidales aproximadas (simplificadas)
vane_th = 6.0
vane_len = L_cyl*0.75
for i in range(pmd_vanes):
    ang = (2*math.pi/pmd_vanes) * i
    # crear placa rectangular y girarla/trasladarla alrededor del centro
    plate = Part.makeBox(r_in*0.9, vane_th, vane_len)
    # centrar placa
    plate.translate(App.Vector(-r_in*0.9/2.0, r_in*0.45, L_cyl*0.15))
    # rotar placa en Z para distribuir
    plate = plate.rotate(App.Vector(0,0,0), App.Vector(0,0,1), ang*180.0/math.pi)
    add_part(plate, "PMD_Vane_%d"%i)

# ---------------------- Motor/Tobera simplificada en un extremo (opcional) ----------------------
nozzle_r = r_in*0.35
nozzle = Part.makeCone(nozzle_r, nozzle_r*0.15, nozzle_r*2.5)
nozzle.translate(App.Vector(0,0,-nozzle_r*1.0))
add_part(nozzle, "Nozzle")

# ---------------------- Etiquetas y dimensionado (texto simple) ----------------------
try:
    import Draft
    # mostrar dimensiones (solo textos con valores)
    txt1 = Draft.makeText(["D_outer = %0.1f mm"%D_outer, "D_inner = %0.1f mm"%D_inner, "L = %0.1f mm"%L_cyl],
                          point=App.Vector(r_out*1.5, -r_out*0.5, L_cyl*0.5))
    txt1.ViewObject.FontSize = 12
except Exception as e:
    # Draft puede no estar disponible en el entorno headless
    pass

# ---------------------- Agrupar en ensamblado (simulado) ----------------------
all_objs = [o for o in doc.Objects]
assembly = doc.addObject('App::DocumentObjectGroup', 'Tanque_Assembly')
assembly.Group = all_objs

# recompute y centrar vista
doc.recompute()
try:
    Gui.SendMsgToActiveView("ViewFit")
except Exception:
    pass

print("Macro listo: Tanque criog\u00e9nico ensamblado (simplificado). Ajusta parametros en la cabecera.")
