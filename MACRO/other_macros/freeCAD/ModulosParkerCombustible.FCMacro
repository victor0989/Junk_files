import FreeCAD as App
import FreeCADGui as Gui
import Part
import Draft
import math

DOC_NAME = "Modulo_Parker_miniISS"
if App.ActiveDocument is None or App.ActiveDocument.Name != DOC_NAME:
    App.newDocument(DOC_NAME)
doc = App.ActiveDocument

# -----------------------
# Parámetros (mm)
# -----------------------
p = {
    # Tanque central
    "D_exterior_total": 1900.0,
    "L_cilindro": 2600.0,
    "Sag_domo": 400.0,
    "t_liner": 2.5,
    "Gap_vacio_MLI": 25.0,
    # Envolvente acanalada
    "h_nervio": 25.0,
    "t_nervio": 3.0,
    "t_env_base": 3.0,
    "pitch_rib": 120.0,
    # Celosía
    "L_pórtico": 1200.0,
    "tubo_OD": 60.0,
    "tubo_t": 2.0,
    # Paneles
    "panel_L": 1600.0,
    "panel_W": 900.0,
    "panel_T": 25.0,
    "ala_span_total": 5000.0,
    # Motor lateral
    "motor_OD": 600.0,
    "motor_L": 850.0,
    "tobera_L": 350.0,
    "tobera_cuello": 95.0,
    "tobera_salida": 220.0,
    # Propelente
    "pipe_OD": 22.0,
    "pipe_t": 1.5,
    # Whipple + brida
    "whipple_t": 2.0,
    "whipple_gap": 40.0,
    "brida_OD": 120.0,
    "brida_t": 10.0,
    "n_tornillos": 6,
    "tornillo_M": 6.0,
}

# Derivados geométricos
R_total = p["D_exterior_total"] / 2.0
R_env_base_out = R_total - p["h_nervio"]                    # radio exterior de la envolvente base
R_env_base_in  = R_env_base_out - p["t_env_base"]           # radio interior de la envolvente base
R_liner_out    = R_env_base_in - p["Gap_vacio_MLI"]         # radio exterior del liner
R_liner_in     = R_liner_out - p["t_liner"]                 # radio interior del liner

# -----------------------
# Utilidades
# -----------------------
def ensure_part_container(name):
    obj = doc.getObject(name)
    if obj is None:
        obj = doc.addObject("App::Part", name)
    return obj

def revolve_profile(profile_edges, axis_p=(0,0,0), axis_dir=(0,1,0), angle=360):
    wire = Part.Wire(profile_edges)
    face = Part.Face(wire)
    solid = face.revolve(App.Vector(*axis_p), App.Vector(*axis_dir), angle)
    return solid

def make_hollow_cylinder(r_in, r_out, length, name):
    outer = Part.makeCylinder(r_out, length)
    inner = Part.makeCylinder(r_in, length)
    return doc.addObject("Part::Feature", name, ).__setattr__("Shape", outer.cut(inner))

def add_feature(shape, name, parent=None):
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = shape
    if parent:
        parent.addObject(obj)
    return obj

def polar_positions(n, radius):
    for i in range(n):
        theta = 2*math.pi*i/n
        yield theta, App.Vector(radius*math.cos(theta), radius*math.sin(theta), 0)

def box_centered(dx, dy, dz):
    box = Part.makeBox(dx, dy, dz)
    box.translate(App.Vector(-dx/2, -dy/2, -dz/2))
    return box

def make_tube_segment(p0, p1, od, t):
    # aproximación: cilindro macizo menos cilindro interior
    v = p1.sub(p0)
    L = v.Length
    axis = App.Vector(0,0,1)
    # cilindro base en Z, luego rotación
    outer = Part.makeCylinder(od/2.0, L)
    inner = Part.makeCylinder((od/2.0 - t), L)
    seg = outer.cut(inner)
    # orientar
    # vector director
    if L > 0:
        rot = App.Rotation(axis, v)
        seg.Placement = App.Placement(p0, rot)
    return seg

# -----------------------
# 1) Liner con domos
# -----------------------
prt_tanque = ensure_part_container("Tanque_Central")

# Cilindro del liner (hueco)
outer = Part.makeCylinder(R_liner_out, p["L_cilindro"])
inner = Part.makeCylinder(R_liner_in, p["L_cilindro"])
liner_cyl = outer.cut(inner)

# Domo torisférico aproximado por perfil de revolución a partir de sag
def make_torispherical_head(R_ext, t, sag, flip=False):
    """Genera domo tipo torisférico de forma robusta."""

    def arco(P1, Pm, P2):
        try:
            return Part.Arc(P1, Pm, P2).toShape()
        except Part.OCCError:
            return Part.makeLine(P1, P2)  # fallback

    # EXTERIOR
    A = App.Vector(R_ext, 0, 0)             # arranque en radio exterior
    V = App.Vector(0, sag, 0)               # vértice domo
    M = App.Vector(R_ext*0.3, sag*0.7, 1.0) # punto intermedio (Z=1 mm evita colinearidad)
    arc_ext = arco(A, M, V)
    eje_ext = Part.makeLine(V, App.Vector(0, 0, 0))
    cierre_ext = Part.makeLine(App.Vector(0, 0, 0), A)
    wire_ext = Part.Wire([arc_ext, eje_ext, cierre_ext])
    if not wire_ext.isClosed():
        wire_ext = Part.Wire(wire_ext.Edges + [Part.makeLine(wire_ext.Vertexes[-1].Point, wire_ext.Vertexes[0].Point)])
    face_ext = Part.Face(wire_ext)
    solid_ext = face_ext.revolve(App.Vector(0,0,0), App.Vector(0,1,0), 360)

    # INTERIOR
    R_int = R_ext - t
    A_i = App.Vector(R_int, 0, 0)
    V_i = App.Vector(0, sag - t, 0)
    M_i = App.Vector(R_int*0.3, (sag - t)*0.7, 1.0)
    arc_int = arco(A_i, M_i, V_i)
    eje_int = Part.makeLine(V_i, App.Vector(0, 0, 0))
    cierre_int = Part.makeLine(App.Vector(0, 0, 0), A_i)
    wire_int = Part.Wire([arc_int, eje_int, cierre_int])
    if not wire_int.isClosed():
        wire_int = Part.Wire(wire_int.Edges + [Part.makeLine(wire_int.Vertexes[-1].Point, wire_int.Vertexes[0].Point)])
    face_int = Part.Face(wire_int)
    solid_int = face_int.revolve(App.Vector(0,0,0), App.Vector(0,1,0), 360)

    # Corte hueco
    head = solid_ext.cut(solid_int)

    if flip:
        head.Placement = App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(0,1,0), 180))
    return head

head_front = make_torispherical_head(R_liner_out, p["t_liner"], p["Sag_domo"], flip=False)
head_rear = make_torispherical_head(R_liner_out, p["t_liner"], p["Sag_domo"], flip=True)

# posicionar domos en extremos del cilindro
head_front.translate(App.Vector(0,0,0))  # proa en x=0
head_rear.translate(App.Vector(0,0,p["L_cilindro"]))  # popa al final del cilindro
# Unir piezas del liner
liner = liner_cyl.fuse([head_front, head_rear])
liner_obj = add_feature(liner, "Liner_AlLi", prt_tanque)

# -----------------------
# 2) Envolvente acanalada (cilindro base + nervios)
# -----------------------
prt_env = ensure_part_container("Envolvente_Acanalada")

# cilindro base (hueco)
env_outer = Part.makeCylinder(R_env_base_out, p["L_cilindro"])
env_inner = Part.makeCylinder(R_env_base_in, p["L_cilindro"])
env_shell = env_outer.cut(env_inner)
env_obj = add_feature(env_shell, "Envolvente_Base", prt_env)

# Nervios longitudinales
circ = 2*math.pi*R_env_base_out
n_ribs = max(6, int(round(circ / p["pitch_rib"])))
rib_len = p["L_cilindro"]
rib_w = p["t_nervio"]
rib_h = p["h_nervio"]

ribs = []
for i, (theta, pos) in enumerate(polar_positions(n_ribs, R_env_base_out + rib_h/2.0)):
    # prisma del nervio
    rib = Part.makeBox(rib_w, rib_h, rib_len)
    # centrar en su propia base
    rib.translate(App.Vector(-rib_w/2.0, -rib_h/2.0, 0))
    # orientar: eje Y radial, X tangencial
    # rotación alrededor Z por theta
    placement = App.Placement()
    placement.Base = App.Vector(0,0,0)
    placement.Rotation = App.Rotation(App.Vector(0,0,1), math.degrees(theta))
    rib = rib.copy()
    rib.Placement = placement
    # trasladar hacia radio adecuado (colocar su centro radial en R_env_base_out + h/2)
    rib.translate(App.Vector(R_env_base_out + rib_h/2.0, 0, 0))
    ribs.append(rib)

if ribs:
    ribs_fused = ribs[0]
    for r in ribs[1:]:
        ribs_fused = ribs_fused.fuse(r)
    ribs_obj = add_feature(ribs_fused, "Nervios", prt_env)
    # opcional: fusionar con envolvente base (dejar separados para FEM/propósitos visuales)
    # env_total = env_shell.fuse(ribs_fused)
    # add_feature(env_total, "Envolvente_Total", prt_env)

# -----------------------
# 3) Estructura de celosía y paneles
# -----------------------
prt_truss = ensure_part_container("Celosia_Paneles_Motor")

# Posición de origen para pórtico (en X lateral desde generatriz del cilindro)
x_attach = R_env_base_out + 50.0  # pequeño ménsula de 50 mm
span_half = p["ala_span_total"]/2.0
# Marco rectangular con tubos
def make_tube_box(width_y, height_x, length_z, od, t, name):
    # Esqueleto simple con 4 largueros y 4 travesaños (frente y fondo)
    tubes = []
    # nodos
    nodes = [
        App.Vector( R_env_base_out,  span_half, 0),
        App.Vector( R_env_base_out, -span_half, 0),
        App.Vector( R_env_base_out + height_x,  span_half, 0),
        App.Vector( R_env_base_out + height_x, -span_half, 0),
        App.Vector( R_env_base_out,  span_half, length_z),
        App.Vector( R_env_base_out, -span_half, length_z),
        App.Vector( R_env_base_out + height_x,  span_half, length_z),
        App.Vector( R_env_base_out + height_x, -span_half, length_z),
    ]
    # Largueros (x) y travesaños (y)
    pairs = [
        (0,2),(1,3),(4,6),(5,7),  # x-dir
        (0,1),(2,3),(4,5),(6,7),  # y-dir (frente y fondo)
        (0,4),(1,5),(2,6),(3,7),  # z-dir (montantes)
    ]
    for a,b in pairs:
        tubes.append(make_tube_segment(nodes[a], nodes[b], od, t))
    # diagonales básicas en caras
    diag_pairs = [(0,7),(1,6),(2,5),(3,4)]
    for a,b in diag_pairs:
        tubes.append(make_tube_segment(nodes[a], nodes[b], od, t))
    shape = tubes[0]
    for s in tubes[1:]:
        shape = shape.fuse(s)
    return add_feature(shape, name, prt_truss)

truss = make_tube_box(span_half*2, p["L_pórtico"], p["L_pórtico"], p["tubo_OD"], p["tubo_t"], "Portico_Tubular")

# Paneles solares: dos por ala (Y+ y Y-), en línea a lo largo de X (hacia fuera)
def make_panel(x_center, y_center, z_center, L, W, T, name, parent):
    panel = box_centered(L, W, T)
    panel.translate(App.Vector(x_center, y_center, z_center))
    return add_feature(panel, name, parent)

panel_gap = 50.0
x0_panel = R_env_base_out + p["L_pórtico"] - p["panel_L"]/2.0
y_pos = span_half - p["panel_W"]/2.0
y_neg = -span_half + p["panel_W"]/2.0
z_mid = p["L_cilindro"]/2.0

make_panel(x0_panel, y_pos, z_mid + p["panel_T"]/2.0 + 20, p["panel_L"], p["panel_W"], p["panel_T"], "Panel_Yplus_1", prt_truss)
make_panel(x0_panel + p["panel_L"] + panel_gap, y_pos, z_mid + p["panel_T"]/2.0 + 20, p["panel_L"], p["panel_W"], p["panel_T"], "Panel_Yplus_2", prt_truss)
make_panel(x0_panel, y_neg, z_mid + p["panel_T"]/2.0 + 20, p["panel_L"], p["panel_W"], p["panel_T"], "Panel_Yminus_1", prt_truss)
make_panel(x0_panel + p["panel_L"] + panel_gap, y_neg, z_mid + p["panel_T"]/2.0 + 20, p["panel_L"], p["panel_W"], p["panel_T"], "Panel_Yminus_2", prt_truss)

# -----------------------
# 4) Motor lateral + placa de montaje
# -----------------------
prt_motor = ensure_part_container("Motor_Lateral")

motor_R = p["motor_OD"]/2.0
# Montar en lado -Y, cerca del extremo de popa
motor_axis_x = R_env_base_out + p["L_pórtico"]/2.0
motor_axis_y = -(span_half - 300.0)  # un poco hacia dentro para dejar margen a paneles
motor_axis_z = p["L_cilindro"]*0.7

# Carcasa cilíndrica
motor_cyl = Part.makeCylinder(motor_R, p["motor_L"])
motor_cyl.rotate(App.Vector(0,0,0), App.Vector(0,0,1), 90)  # eje en -Y
motor_cyl.translate(App.Vector(motor_axis_x, motor_axis_y - p["motor_L"]/2.0, motor_axis_z))
motor_cyl_obj = add_feature(motor_cyl, "Carcasa_Motor", prt_motor)

# Tobera (conos combinados)
neck_R = p["tobera_cuello"]/2.0
exit_R = p["tobera_salida"]/2.0
# tramo convergente-cilíndrico simple
nozzle = Part.makeCone(exit_R, neck_R, p["tobera_L"])
nozzle.rotate(App.Vector(0,0,0), App.Vector(0,0,1), 90)
# posicionar desde salida pegada a carcasa
nozzle.translate(App.Vector(motor_axis_x, motor_axis_y - p["motor_L"]/2.0 - p["tobera_L"], motor_axis_z))
nozzle_obj = add_feature(nozzle, "Tobera", prt_motor)

# Placa de montaje en truss (para cargas FEM)
plate = Part.makeBox(300, 20, 300)  # 300x20x300 mm
plate.translate(App.Vector(motor_axis_x, motor_axis_y + 50.0, motor_axis_z - 150))
plate_obj = add_feature(plate, "Placa_Motor", prt_motor)

# -----------------------
# 5) Tuberías propelente
# -----------------------
prt_pipes = ensure_part_container("Lineas_Propelente")
# Puerto en el cilindro (lado -Y), hacia popa
port_x = R_liner_out * math.cos(-math.pi/2)
port_y = R_liner_out * math.sin(-math.pi/2)
port_z = p["L_cilindro"]*0.6
P0 = App.Vector(port_x, port_y, port_z)
P1 = App.Vector(R_env_base_out+50, port_y, port_z)
P2 = App.Vector(R_env_base_out+50, motor_axis_y, motor_axis_z)
seg1 = make_tube_segment(P0, P1, p["pipe_OD"], p["pipe_t"])
seg2 = make_tube_segment(P1, P2, p["pipe_OD"], p["pipe_t"])
pipes = seg1.fuse(seg2)
pipes_obj = add_feature(pipes, "Lineas_DN20", prt_pipes)

# Brida de recarga en domo de proa (+X)
prt_interfaces = ensure_part_container("Interfaces")
br_flange_R = p["brida_OD"]/2.0
flange = Part.makeCylinder(br_flange_R, p["brida_t"])
# colocar sobre domo frontal, eje +X: simplificación en x=0 con ligera separación
flange.rotate(App.Vector(0,0,0), App.Vector(0,1,0), 90)
flange.translate(App.Vector(0 + 5.0, 0, p["L_cilindro"]/3.0))
flange_obj = add_feature(flange, "Brida_Recarga", prt_interfaces)

# Taladros M6 en patrón de 6
holes = []
pcd = br_flange_R*0.7
for i in range(p["n_tornillos"]):
    ang = 2*math.pi*i/p["n_tornillos"]
    hx = (0 + 5.0)
    hy = pcd*math.cos(ang)
    hz = p["L_cilindro"]/3.0 + pcd*math.sin(ang)
    hole = Part.makeCylinder(p["tornillo_M"]/2.0, p["brida_t"] + 2.0)
    hole.rotate(App.Vector(0,0,0), App.Vector(0,1,0), 90)
    hole.translate(App.Vector(hx, hy, hz))
    holes.append(hole)
if holes:
    holes_union = holes[0]
    for h in holes[1:]:
        holes_union = holes_union.fuse(h)
    flange_drilled = flange.cut(holes_union)
    flange_obj.Shape = flange_drilled

# -----------------------
# 6) Escudo Whipple de proa
# -----------------------
prt_whipple = ensure_part_container("Whipple")
whipple_R = R_total + 20.0
disc = Part.makeCylinder(whipple_R, p["whipple_t"])
disc.rotate(App.Vector(0,0,0), App.Vector(0,1,0), 90)
disc.translate(App.Vector(-p["whipple_gap"], 0, p["L_cilindro"]/2.0))
add_feature(disc, "Whipple_Proa", prt_whipple)

# -----------------------
# 7) FEM: contenedor, materiales y cargas básicas
# -----------------------
try:
    import Fem
    import ObjectsFem
    prt_fem = ensure_part_container("FEM")

    analysis = doc.addObject('Fem::FemAnalysis', 'Analysis')
    prt_fem.addObject(analysis)

    # Materiales aproximados
    mat_liner = ObjectsFem.makeMaterialSolid(doc, 'Mat_AlLi2195')
    mat_liner.Material = {
        'Name':'Al-Li 2195',
        'YoungsModulus':'76000000000 Pa',
        'PoissonRatio':'0.33',
        'Density':'2650 kg/m^3'
    }
    analysis.addObject(mat_liner)
    mat_titanio = ObjectsFem.makeMaterialSolid(doc, 'Mat_Ti64')
    mat_titanio.Material = {
        'Name':'Ti-6Al-4V',
        'YoungsModulus':'114000000000 Pa',
        'PoissonRatio':'0.34',
        'Density':'4430 kg/m^3'
    }
    analysis.addObject(mat_titanio)

    # Asignar materiales por objeto (nota: para cálculo real, usar sólidos separados/meshes por material)
    mat_liner.References = [(liner_obj, '')]
    mat_titanio.References = [(truss, '')]

    # Presión interna 1.5 bar(g) en cara cilíndrica interior del liner
    # Filtrar cara cilíndrica de radio ~ R_liner_in
    cyl_faces = []
    for f in liner_obj.Shape.Faces:
        try:
            surf = f.Surface
            if hasattr(surf, 'Radius') and abs(surf.Radius - R_liner_in) < 1.0:
                cyl_faces.append((liner_obj, f))
        except:
            pass
    if cyl_faces:
        pres = ObjectsFem.makeConstraintPressure(doc, 'Presion_Interna')
        pres.Pressure = 150000  # Pa
        pres.References = [(liner_obj, [f for f in range(1, len(liner_obj.Shape.Faces)+1) if abs(getattr(liner_obj.Shape.Faces[f-1].Surface,'Radius',0)-R_liner_in)<1.0])]
        analysis.addObject(pres)

    # Inercia 6g axial (+X)
    g = ObjectsFem.makeConstraintSelfWeight(doc, 'Inercia_6g')
    g.Gravity_x = 9.81*6
    g.Gravity_y = 0
    g.Gravity_z = 0
    analysis.addObject(g)

    # Fuerza 5 kN en placa de motor (para torsión excéntrica)
    force = ObjectsFem.makeConstraintForce(doc, 'Empuje_Descentrado')
    force.Force = 5000.0
    # aplicar en cara grande superior de la placa (puedes ajustar el índice si es necesario)
    face_ids = [i+1 for i,f in enumerate(plate_obj.Shape.Faces) if abs(f.BoundBox.XLength-300)<1 and abs(f.BoundBox.ZLength-300)<1]
    if face_ids:
        force.References = [(plate_obj, face_ids)]
    analysis.addObject(force)

    # Solver modal (frecuencias) y estático (placeholders)
    solver = ObjectsFem.makeSolverCalculixCcxTools(doc, 'SolverCcx')
    solver.AnalysisType = 'frequency'
    analysis.addObject(solver)

    # Malla placeholder (requiere Gmsh/Netgen instalados para ejecutar el solve)
    mesh = doc.addObject('Fem::FemMeshObject', 'Mesh')
    analysis.addObject(mesh)

except Exception as e:
    App.Console.PrintMessage("FEM setup parcial: revisa Workbench FEM instalado.\n")

doc.recompute()
Gui.SendMsgToActiveView("ViewFit")
